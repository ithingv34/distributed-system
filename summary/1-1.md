# 클러스터 코디네이션, 리더 선출 알고리즘

- **노드**, **클러스터**
- **분산 시스템에서 서로 다른 노드간의 역할을 조정하는 문제**
- **주키퍼 (분산 시스템 코디네이터)** 
- **주키퍼의 특징**
- **리더 선출 알고리즘**


#### 노드

- 노드는 분산 시스템의 일부로 동작하는 시스템에서 실행되는 프로세스이다. 분산 시스템에서는 두 노드 사이에 선분이 있으면 두 프로세스가 네트워크를 통해 서로 통신할 수 있다는 뜻이다.

#### 클러스터

- 클러스터는 서로 연결된 노드의 모음이다. 한 클러스터의 노드들은 동일한 작업을 수행하며 일반적으로 동일한 코드로 실행된다.

---

### 분산 시스템에서 서로 다른 노드간의 역할을 조정하는 문제

- 분석해야 할 데이터의 양이 매우 많거나 복잡한 계산이 필요한 경우, 이 작업을 노드가 모여 있는 클러스터를 구성할 수 있다. 하지만 문제는 **어느 노드에서 어떤 작업을 수행할 것인가** 이다. 
  
- 분산 시스템의 가장 큰 이점은 작업을 병렬화하고, 각 노드가 공동의 목표를 위해 독립적으로 동작하도록 할 수 있다.  

- 이러한 작업을 수동으로 분배해서 각 노드에 별도의 작업을 할당할 수도 있다. 하지만 이런 방식에는 확장성이 없다. 초당 수천 개의 작업을 요청받을 수도 있기 때문에 작업을 분산하기 위한
프로그램이 필요하다. 

- 전부 수동으로 분배하는 대신 노드 하나를 직접 선택해 리더나 마스터로 지정할 수 있다. 마스터로 지정된 노드는 작업 분배와 결과 수집을 담당한다. 

- 하지만 문제는 마스터 노드를 포함한 모든 노드가
언제든 작업 수행에 실패할 수 있다. 

- 대규모 분산 시스템에는 당연히 장애가 발생하지만 언제 발생하는지가 문제이다. 리더 노드가 작업을 배포하지 않거나 결과를 수집하지 않으면 클러스터 전체가 동작하지 않게 된다.

- 해결책은 노드들이 필요에 따라 리더 노드를 직접 선출하고 모든 노드가 리더의 상태를 예의주시하도록
알고리즘을 구축하는 것이다.

- 마스터 노드가 동작할 수 없게 되면 나머지 노드들이 리더를 다시 선택합니다 나중에 이전 리더가 실패를 회복하고 다시 클러스터에 합류할 때는 자신이 리더 노드가 아니라는 걸 깨닫고 작업을 돕는 일반 노드로 참여하게 된다.

- 기본적으로 각 노드는 자기 자신만 인식하고 클러스터의 다른 구성원에 대해서는 알지 못합니다

- 그래서 서비스 레지스트리와 서비스 디스커버리 솔루션이 필요하다.

- 또한 고장 감지 장치가 필요하다. 리더 노드를
사용할 수 없게 되면 클러스터의 다른 노드들에게 알려서 자동적으로 리더를 다시 뽑을 수 있어야 한다.

----

### 주키퍼 (분산 시스템 코디네이터)

- 아파치 주키퍼는 분산 시스템을 위해 특별히 설계된 고성능의 분산 코디네이터이다. 주키퍼는 카프카(Kafka), 하둡(Hadoop), HBase 같은 범용 프로젝트와 다양한 프로젝트에서 사용된다.

- 주키퍼는 클러스터에 알고리즘을 구현할 때 시각적으로 볼 수 있도록 추상화 계층을 제공한다.
그리고 호환성 높은 알고리즘을 사용함으로써 높은 가용성과 신뢰성을 보장한다.

- 운영시 일반적으로 3개 이상의 노드로구성된 클러스터로 실행됩니다 이런 특성 덕분에 우리는 주키퍼 노드 하나를 잃어도 시스템이 온전히 작동하도록 유지할 수 있다.

- 노드들이 서로 통신하여 작업을 조정하는 대신
노드들이 주키퍼 서버와 직접 통신하도록 하는 방식으로 주키퍼를 사용한다.


### 주키퍼의 특징

- 주키퍼는 사용하기 쉬운 소프트웨어 추상화 도구와 데이터 모델을 제공한다. 마치 트리 구조처럼 보여서 파일 시스템과 아주 비슷한데, 이 트리 또는 가상 파일 시스템의 각 요소를 Z노드라고 부른다.

- Z노드는 파일과 디렉터리의 중간 형태이며 파일처럼 내부에 데이터를 저장할 수도 있고 디렉터리처럼 하위 노드를 가질 수도 있다, 

- Z노드에는 영구 노드와 임시 노드 두 가지 유형이 있습니다 영구 Z노드는 세션이 끊어져도 남아있습니다 다시 말해, 응용 프로그램이 주키퍼와 연결이 끊어졌다가 다시 연결돼도 프로그램이
만든 영구 Z노드는 모든 하위 데이터와 함께 그대로 유지된다.

- 하지만 임시 Z노드는 정반대이다. 임시 노드는 해당 Z노드를 만든 응용 프로그램이 주키퍼와 연결이 끊어지는 즉시 삭제된다, 여기서 임시 Z노드가 임시 노드를 생성한 다른 노드가 중단되었는지 확인할 수 있는

----

### 리더 선출 알고리즘 설계

1. 첫 번째 단계에서는 주키퍼와 연결된 모든 노드가 리더 후보에 자원한다. 각 노드는 선거에 출마하기 위해 자신을 나타내는 Z노드를 election 부모 노드 밑에 추가한다. 주키퍼는 전체 순서를 관리하므로
추가 순서에 따라 각 Z노드의 이름을 지정할 수 있다.

2. 두 번째 단계에서 각 노드는 Z노드 생성을 마친 후 election 부모 노드에게 현재 자식 노드들을 물어봅니다 노드 순서는 주키퍼가 우리에게 제공하기 때문에 각 노드는 election 부모 노드의 자식 노드를
자신이 Z노드를 생성하기 전에 생성된 모든 Z노드를 볼 수 있습니다 

3. 세 번째 단계에서 현재 노드가 만든 Z노드의 숫자가 가장 작다면 해당 노드가 리더라는 것을
알 수 있습니다, 반대로 현재 노드인 Z노드의 숫자가 가장 작지 않다면 그 노드는 리더가 아니라는 것을 알 수 있죠 그런 노드는 새로 뽑힌 리더 노드의 지시를 기다립니다 이것이 우리가 동등한 노드 사이에서 리더 노드를 뽑고 합의에 도달하는 방법이다.